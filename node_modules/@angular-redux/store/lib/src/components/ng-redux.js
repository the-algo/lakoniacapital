"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var redux_1 = require("redux");
var Observable_1 = require("rxjs/Observable");
var BehaviorSubject_1 = require("rxjs/BehaviorSubject");
require("rxjs/add/operator/map");
require("rxjs/add/operator/filter");
require("rxjs/add/operator/distinctUntilChanged");
require("rxjs/add/operator/switchMap");
var get_in_1 = require("../utils/get-in");
var NgRedux = (function () {
    /** @hidden */
    function NgRedux(ngZone) {
        var _this = this;
        this.ngZone = ngZone;
        this._store = null;
        this._store$ = null;
        /**
         * Get the current state of the application
         * @returns The application state
         */
        this.getState = function () { return _this._store.getState(); };
        /**
         * Subscribe to the Redux store changes
         *
         * @param listener A callback to invoke when the state is updated
         * @returns A function to unsubscribe
         */
        this.subscribe = function (listener) { return _this._store.subscribe(listener); };
        /**
         * Replaces the reducer currently used by the store to calculate the state.
         *
         * You might need this if your app implements code splitting and you want to
         * load some of the reducers dynamically. You might also need this if you
         * implement a hot reloading mechanism for Redux.
         *
         * @param nextReducer The reducer for the store to use instead.
         */
        this.replaceReducer = function (nextReducer) {
            return _this._store.replaceReducer(nextReducer);
        };
        /**
         * Dispatch an action to Redux
         */
        this.dispatch = function (action) {
            if (!_this._store) {
                throw new Error('Dispatch failed: did you forget to configure your store? ' +
                    'https://github.com/angular-redux/@angular-redux/core/blob/master/' +
                    'README.md#quick-start');
            }
            // Some apps dispatch actions from outside the angular zone; e.g. as
            // part of a 3rd-party callback, etc. When this happens, we need to
            // execute the dispatch in-zone or Angular2's UI won't update.
            return _this.ngZone.run(function () { return _this._store.dispatch(action); });
        };
        this.storeToObservable = function (store) {
            return new Observable_1.Observable(function (observer) {
                observer.next(store.getState());
                store.subscribe(function () { return observer.next(store.getState()); });
            });
        };
        NgRedux.instance = this;
        this._store$ = new BehaviorSubject_1.BehaviorSubject(undefined)
            .filter(function (n) { return n !== undefined; })
            .switchMap(function (n) { return _this.storeToObservable(n); });
    }
    /**
     * configures a Redux store and allows NgRedux to observe and dispatch
     * to it.
     *
     * This should only be called once for the lifetime of your app, for
     * example in the constructor of your root component.
     *
     * @param reducer Your app's root reducer
     * @param initState Your app's initial state
     * @param middleware Optional Redux middlewares
     * @param enhancers Optional Redux store enhancers
     */
    NgRedux.prototype.configureStore = function (reducer, initState, middleware, enhancers) {
        if (middleware === void 0) { middleware = []; }
        if (enhancers === void 0) { enhancers = []; }
        if (this._store) {
            throw new Error('Store already configured!');
        }
        var reTypedCompose = redux_1.compose;
        var finalCreateStore = reTypedCompose.apply(void 0, [redux_1.applyMiddleware.apply(void 0, middleware)].concat(enhancers))(redux_1.createStore);
        var store = finalCreateStore(reducer, initState);
        this.setStore(store);
    };
    /**
     * Accepts a Redux store, then sets it in NgRedux and
     * allows NgRedux to observe and dispatch to it.
     *
     * This should only be called once for the lifetime of your app, for
     * example in the constructor of your root component. If configureStore
     * has been used this cannot be used.
     *
     * @param store Your app's store
     */
    NgRedux.prototype.provideStore = function (store) {
        if (this._store) {
            throw new Error('Store already configured!');
        }
        this.setStore(store);
    };
    ;
    /**
     * Select a slice of state to expose as an observable.
     *
     * @typeparam S
     * @param selector key or function to select a part of the state
     * @param [comparer] Optional
     * comparison function called to test if an item is distinct
     * from the previous item in the source.
     *
     * @returns An Observable that emits items from the
     * source Observable with distinct values.
     */
    NgRedux.prototype.select = function (selector, comparator) {
        var result;
        var changedStore = this._store$.distinctUntilChanged();
        if (!selector) {
            return this._store$.distinctUntilChanged(comparator);
        }
        else if (typeof selector === 'string' ||
            typeof selector === 'number' ||
            typeof selector === 'symbol') {
            result = changedStore.map(function (state) { return state[selector]; });
        }
        else if (Array.isArray(selector)) {
            result = changedStore.map(function (state) { return get_in_1.getIn(state, selector); });
        }
        else {
            result = changedStore.map(selector);
        }
        return result.distinctUntilChanged(comparator);
    };
    NgRedux.prototype.setStore = function (store) {
        this._store = store;
        this._store$.next(store);
    };
    return NgRedux;
}());
/** @hidden */
NgRedux.instance = undefined;
exports.NgRedux = NgRedux;
;
//# sourceMappingURL=ng-redux.js.map